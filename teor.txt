Клиент-серверное приложение - приложение (программа) с клиент-серверной архитектурой: приложение, состоящее из двух компонент – клиента и сервера; клиент и сервер взаимодействуют между собой в соответствии с заданными правилами (спецификациями, протоколами); для взаимодействия между клиентом и сервером в соответствии с правилами (спецификацией, протоколом) должно быть установлено соединение; инициатором соединения всегда является клиент.  
web-приложение -клиент-серверное приложение, у которого клиент и сервер взаимодействуют по протоколу HTTP.
Операция называется асинхронной, если ее выполнение  осуществляется в 2 фазы: 1) заявка на исполнение; 2) получение результата; при этом участвуют два механизма: A-механизм, формирующий заявку и потом  получающий результат; B-механизм, получающий заявку от A, исполняющий операцию и отправляющий результат A; продолжительность исполнения операции B-механизмом, как правило, непредсказуемо; в то время пока B-механизм исполняет операцию, А-механизм выполняет собственную работу. Применение асинхронности не противоречит применению многопоточности.
HTTP: основные свойства 
⦁	версии HTTP/1.1 – действующий (текстовый), HTTP/2 – черновой (не распространен, бинарный); 
⦁	два типа абонентов: клиент и сервер;
⦁	два типа сообщений: request и response;
⦁	от клиента к серверу – request;
⦁	от сервера к клиенту – response;
⦁	на один request всегда один response, иначе ошибка;
⦁	одному response всегда один request,  иначе ошибка; 
⦁	TCP-порты: 80, 443(https);
⦁	для адресации используется URI или URN;
⦁	поддерживается W3C, описан в нескольких RFC.  
HTTPS (аббр. от англ. HyperText Transfer Protocol Secure) — расширение протокола HTTP для поддержки шифрования в целях повышения безопасности. Данные в протоколе HTTPS передаются поверх криптографических протоколов TLS. В отличие от HTTP с TCP-портом 80, для HTTPS по умолчанию используется TCP-порт 443.

Создание сервера:  
Чтобы создать сервер, следует вызвать метод http.createServer():
const http = require("http");
http.createServer().listen(3000);
Метод createServer() возвращает объект http.Server. Но чтобы сервер мог прослушивать и обрабатывать входящие подключения, у объекта сервера необходимо вызвать метод listen(), в который в качестве параметра передается номер порта, по которому запускается сервер. Для обработки подключений в метод createServer можно передать специальную функцию:
const http = require("http");
http.createServer(function(request, response){
    response.end("Hello world!");
}).listen(3000);
Эта функция принимает два параметра:
    request: хранит информацию о запросе
    response: управляет отправкой ответа

Запрос(Request): серверный объект, который образуется в результате обработки сервером http-запроса, поступающего от клиента и передается серверному программному коду для обработки. Содержит: всю информацию из http-запроса: метод, коллекция заголовков, коллекция параметров, поток данных … Обычно объект Request предоставляет возможность хранить данные в формате ключ/значение.

Request:
⦁	метод;
⦁	URI;
⦁	версия протокола (HTTP/1.1);
⦁	заголовки (пары: имя/заголовок);
⦁	параметры (пары: имя/заголовок);
⦁	расширение.

Ответ(Response): серверный объект, который автоматически формируется сервером, при получении http-запроса (одновременно с объектом Request), заполняется данными серверными программным кодом, преобразуется в http-ответ и отправляется клиенту.  Содержит: всю информацию, которая должна быть помещена в http-ответ:  статус, коллекция заголовков, поток данных, … 

Response:
⦁	версия протокола (HTTP/1.1);
⦁	код состояния (1xx, 2xx, 3xx, 4xx, 5xx);
⦁	пояснение к коду состояния;
⦁	заголовки (пары: имя/заголовок);
⦁	расширение.

Request-методы:
 
Заголовки:
⦁	General: общие заголовки, используются в запросах и ответах;
 

⦁	Request: используются только в запросах;
 

⦁	Response: используются только в ответах;
 

⦁	Entity: для сущности в ответах и запросах.
 
Response: Код состояния:
⦁	1xx: информационные сообщения;
⦁	2xx: успешный ответ;
⦁	3xx: переадресация;
⦁	4xx: ошибка клиента;
⦁	5xx: ошибка сервера.

URI: Uniform Resource Identifier – унифицированный идентификатор ресурса (документ, изображение, файл, служба, электронная почта,…).

URL: Uniform Resource Location -  унифицированный локатор ресурса , содержащий местонахождение ресурса и способ обращения (протокол) к ресурса, описывает множество URI.

URN: Uniform Resource Name  -  унифицированное  имя ресурса – URI, имя ресурса, не содержащее месторасположение и способ доступа к ресурсу. В будущем URN должен заменить URL (для решения проблем с перемещением ресурсов в Internet).

Web-ресурс приложения: сущность, расположенная на стороне сервера и имеющая URL/URI, к которой можно сделать http-запрос и получить http-ответ.  

Web-ресурсы приложения: статические - отправляются клиенту без изменения (html-страницы, рисунки, видео-файлы, …),  динамические – динамически (программно) формируются на сервере и отправляются клиенту (сервлеты, JSP, http-обработчики, aspx-страницы,…). Ресурс может быть статическим относительно сервера и динамическим относительно клиента (html-страницы с JavaScript).  

Сессия (Session): серверный объект, хранящий информацию о соединении с клиентом, создается при первом обращении  время жизни: timeout (системный параметр, обычно равен 10 – 30 минутам) – максимальное время между запросами клиента. Если  timeout превышен, то Session разрушается и при следующем запросе создается новый экземпляр. Каждая сессия имеет собственный идентификатор (Session ID, 16 или более байт). Каждый Request принадлежит, какой-то сессии (имеет ссылку на объект Session или содержит Session ID). Обычно объект Session предоставляет  приложению возможность хранить данные в формате ключ/значение. 

Контекст web-приложения: серверный объект, предназначенный для хранения информации об  одом web-приложении, общий для всех файлов. Как правило, формируется сразу при загрузке web-сервера, основные данные (параметры приложения) копируются из конфигурационного файла приложения, общий для всех сессий приложения,   Обычно контекст предоставляет возможность хранить данные в формате ключ/значение. 
Фильтр (Filter): серверный объект – препроцессор запроса, предназначен для предварительной обработки объекта Request. К одному ресурсу может быть построена цепочка фильтров, последний в цепочке – ресурс. Фильтр может прервать цепочку и сам сформировать ответ клиенту. Один и тот же фильтр может быть применен к нескольким ресурсам. В качестве параметров фильтр получает объекты Request и  Response, которые от передает дальше по цепочке или обрывает цепочку и заполняет объект Response. 
Слушатели событий (Lister): серверные объекты – для обработки событий жизненного цикла web-приложения.
Кэш (Cache): серверный объект, предназначенный для временного хранения данных с целью ускорения выполнения запроса. Кэширование – процессы записи и извлечения данных в/из Cache. Различают кэширование данных и кэширование вывода. Кэширование данных – кэширование часто используемых данных. Кэширование вывода – кэширование объекта Response. 
Синхронный http-запрос: запрос, при котором поток, выдавший http-запрос, блокируется до поступления запроса.  
Асинхронные запросы: запрос, при котором поток, выдавший http-запрос, не блокируется до поступления запроса; для обработки ответа применяется функция обратного вызова. 
NODEJS: программная платформа для разработки  серверных web-приложений на языке JS/V8. Свойства:
⦁	основан на Chrome V8;
⦁	среда исполнения приложений на JavaScript;
⦁	поддерживает механизм асинхронности;
⦁	ориентирован на события;
⦁	однопоточный (код приложения исполняется только в одном потоке, один стек вызовов); обычно в серверах для каждого соединения создается свой поток, в Node.js все соединения обрабатываются в одном JS-потоке;
⦁	не блокирует выполнение кода при вводе/выводе;
⦁	в состав Node.js входят инструменты: npm – пакетный менеджер; gyp - Python-генератор проектов; gtest – Google фреймворк для тестирования С++ приложений;   
⦁	использует библиотеки: V8 – библиотека V8 Engine, libuv – библиотека для абстрагирования неблокирующих операций ввода/вывода;  http-parser – легковесный парсер http-сообщений (написан на C и не выполняет никаких системных вызовов); c-ares  - библиотека для работы с DNS; OpenSSL – библиотека для криптографии;  zlib – сжатие и распаковка.

EventEmitter: JS-класс, предоставляющий функциональность для асинхронной обработки событий в Node.js. Событие в  программном  объекте – это процесс перехода  объекта из одного состояние в другое. При этом,  об этом переходе могут быть извещены другие объекты. У события есть издатель (или генератор) события и могут быть подписчики (или обработчики) события. EventEmitter: необходимо включения двух модулей: events и util.

JSON: JavaScript Object Notation, текстовый формат передачи данных
WebSocket — протокол связи поверх TCP-соединения, предназначенный для обмена сообщениями между браузером и веб-сервером в режиме реального времени.  Он позволяет пересылать любые данные, на любой домен, безопасно и почти без лишнего сетевого трафика.
WebSocket представляет собой альтернативу HTTP, его можно применять для организации обмена данными в веб-приложениях. Этот протокол позволяет создавать долгоживущие двунаправленные каналы связи между клиентом и сервером. После установления соединения канал связи остаётся открытым, что даёт в распоряжение приложения очень быстрое соединение, характеризующееся низкими задержками и небольшой дополнительной нагрузкой на систему. Протокол WebSocket поддерживают все современные браузеры.
HTTP и WebSocket — это очень разные протоколы, в которых используются различные подходы к обмену данными. HTTP основан на модели «запрос — ответ»: сервер отправляет клиенту некие данные после того, как они будут запрошены. В случае с WebSocket всё устроено иначе. А именно:
Сервер может отправлять сообщения клиенту по своей инициативе, не дожидаясь поступления запроса от клиента.
Клиент и сервер могут обмениваться данными одновременно.
Протокол WebSocket очень хорошо подходит для организации связи в режиме реального времени по каналам, которые долго остаются открытыми. HTTP, в свою очередь, отлично подходит для организации эпизодических сеансов связи, инициируемых клиентом. В то же время надо отметить, что, с точки зрения программирования, реализовать обмен данными по протоколу HTTP гораздо проще, чем по протоколу WebSocket.
Каналы связи:
1)	Дуплексный – одновременно и прием, и передача (TCP, WebSocket)
2)	Полудуплексный – одноврем.только прием или только передача (HTTP)

Чаще всего WS используется для работы с браузерным клиентом (npm install ws)
Атрибуты:
*onopen – когда соед.устан.
	*onclose – соед.закрыто
	*onmessage – д-е получены
	*onerror – ошибка
	*readystate – тек.сост.подключ
	*url – url созд.к-ром
Константы:
ReadyState: (константы сост.готовности)
	*connecting – соед. еще не открыто
	*open – открыто и готово к обмену д-ми
	*closing – соед.в проц.закртыия
	*closed – соед.закрыто или не м.открыться
Методы:
	*close – закрывает WS-подключение или заканчив.попытку подключ.
(если уже закрыто – ничего не делает)
	*send – передаем д-е через WS-соед

Взаимод.с потоками:
	Канал соед.м.представить в виде дуплексн.потока => м.и чит., и пис.д-е одноврем.

	Поток – абстракция, кри.позвол представить д-е в виде потока байт.

Механизм ping/pong – механизм для проверки соед.
	*С посыл.сообщ ping для проверки соед., К.должен ответить сообщ pong
	*делаем к С ping , C возвращ.pong

RPC (remote procedure call) – удаленный вызов процедур
	- это технология, кот.позвол.прогам вызыв.процедуры и ф-ции в др.адресном пр-ве (как правило на удал.ПК). Т.е.на С генер.методы, а К их вызыв.
	*npm install rpc-websockets	

Rpc-сервер 		*в кач-ве трансорта исп. WS
			*регестрир.удал процедуру
				(имя, ф-ция, .public()/.protected)

*Если public – клиент не завершается
*Если protected – требует аутентификации (логин/пароль)

Процесс установки соед:
Upgrade – К просит С переключится на новый протокол (WebSocket)
Процесс «рукопожатия» - процесс установки соед по новому протоколу:
	К посыл обычный HTTP-запрос на С с заголовком upgrade кот сообщ.С, что К хочет устан.WS-соед.

GraphQL: формальный язык запросов; особенности: позволяет делать агрегированные запросы (можно в одном запросе запросить все необходимые данные), использует систему типов. 
веб-сервис – веб-прил, интерфейс не для конеч. юзера, а для др. прилож
Интерфейсы:
* RPC
* REST – выда. в виде набора URI и инструкций к ним. Каждый ресурс предост. в виде коллекции, но там нет стандарта
GraphQL – позв. несоклько упорядочить работу с REST-сервисами, пока нет стандартов
Компоненты GraphQL:
- схема
- query bootage subscription
- resolver (разрешители)

3 типа заданий, кот. К м дать Су с пом GraphQL:
- Query
- Mutation
- Subscription

* Schema – описание ТД, кот. К м. исп в Q/M/S (запросах)
* Resolver – наш код (сами писали), кот. придает смысл запросам, кот. приходят на GraphQL. обраб. компонент запроса и превра в др. запрос.
имена св-в объекта resolver совпад. с именами запросов, кот. есть в схеме
* Mutation – запросы, кот. приводят к измен данныхх (удал, изм, доб). Особый тип, кот. использ нотацию input

Мы даем схему прогеру, он ее получает по GET запросу и по ней делает запросы. В схеме: Fac! – не мб пустым, [pulpits!] – массив/колл pulpit-ов, сама коллекция мб пустой (нет эл-тов), но если есть эл-ты, они не мб пустыми. [ ]! – непуст. колл, допуск. пустые эл-ты

//Pipe - это канал, который связывает поток для чтения и поток для записи и позволяет сразу считать из потока чтения в поток записи.
Для чего они нужны? Возьмем, к примеру проблему копирования данных из одного файла в другой.
У потока чтения вызывается метод pipe(), в который передается поток для записи.


========================================================
Redis

Redis - oSQL СУБД с открытым кодом: 
-	хранилище данных в оперативной памяти;
-	для кэша;
-	для посредника сообщений;
-	структуры данных: строки, хэш-таблицы, списки, наборы, отсортированные наборы, растровые изображения, геопространственные индексы, HyperLogLog;
-	СУБД ориентирована на быстрое выполнение атомарных операций; 
-	механизм снимков для асинхронного сохранения (с потерями);
-	механизм упреждающей записи;   
-	API: C, C++, C#, Java, JavaScript, Python, … ; 
-	работает только под Linux.
- Если сервер откажет между двумя синхронизациями с диском — вы потеряете всё что сидело в памяти.

HyperLogLog - это алгоритм для задачи, связанной с подсчетом, аппроксимирующей количество различных элементов в мультимножестве. Для вычисления точного количества элементов мультимножества требуется объем памяти, пропорциональный количеству элементов, что нецелесообразно для очень больших наборов данных.

1.	Поясните понятие in-memory Database.
Резидентная база данных хранящаа информацию в оперативной памяти
2.	Поясните понятие хэш-таблица.
Хеш-табли́ца — это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары и выполнять три операции
3.	Каким образом обеспечивается персистентность  данных в СУБД Redis?
Персистентные структуры — это структуры данных, которые при внесении в них каких-то изменений сохраняют все свои предыдущие состояния и доступ к этим состояниям.
Redis сохраняет свое состояние на диск
4.	Поясните назначение команд СУБД Redis:  set, get, del, getset.
Вставка, получение, удаление, вставка нового значение + получение старого
5.	Поясните назначение команд СУБД Redis:  incr, decr.
Увеличить или уменьшить значения на 1
6.	Поясните назначение команд СУБД Redis:  mset, mget.
Вставка, получение нескольких полей за раз
7.	Поясните назначение команд СУБД Redis:  hset, hget.
hset - Устанавливает поле в хэше, хранящемся в ключе к значению. Если ключ не существует, создается новый ключ, содержащий хэш. Если поле уже существует в хэше, оно перезаписывается.  
hget - Получает поле в хэша, хранящемся в ключе к значению 
8.	Поясните назначение команд СУБД Redis:  hmset,hmget.
Hmset - Устанавливает для нескольких полей их соответствующие значения в хэше, хранящемся в ключе. Эта команда перезаписывает любые указанные поля, уже существующие в хэше. Если ключ не существует, создается новый ключ, содержащий хэш.    
9.	Поясните назначение команды СУБД Redis: exists. 
Проверка на существование значения по ключу   


Sequelize 

ORM: Object-Relational Mapping  - технология программирования, которая позволяет работать с SQL-базой данных, как с набором программных объектов. 

Mapping: база данных – объект contextDB, таблица – коллекция объектов, строка в таблице – объект, структура таблицы – класс.    

Sequelize - это ORM-библиотека для приложений на Node.js, которая осуществляет сопоставление таблиц в бд и отношений между ними с классами. При использовании Sequelize мы можем не писать SQL-запросы, а работать с данными как с обычными объектами. Причем Sequelize может работать с рядом СУБД - MySQL, Postgres, MariaDB, SQLite, MS SQL Server.

1.	Поясните понятие «ORM»
ORM (Object-Relational Mapping) – технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных»
2.	Какой дополнительный пакет необходимо установить для работы sequelize c Microsoft SQL Server?
tedious
3.	Поясните понятие «sequelize-схема».
Схема таблиц базы данных на основе объектов
4.	Какая функция sequelize позволяет выполнить SELECT-запрос?
findAll
5.	Какая функция sequelize позволяет выполнить INSERT-запрос?
create
6.	Какая функция sequelize позволяет выполнить UPDATE-запрос?
update
7.	Какая функция sequelize позволяет выполнить DELETE-запрос?
destroy
8.	Поясните назначение функции sequelize Схема.hasMany. 
9.	Поясните понятие «raw query». 
.query(‘’) – запрос на языке sql
10.	Поясните понятие «code first».
Сначала создается код схемы для создания бд
11.	Поясните понятие «транзакция». 
Набор sql команд, которые все однозначно выполняются

Express 

Express - фреймворк, который использует модуль http, но вместе с тем предоставляет ряд готовых абстракций, которые упрощают создание сервера и серверной логики, в частности, обработка отправленных форм, работа с куками, CORS и т.д.
Для обработки запросов в Express определено ряд встроенных функций, и одной из таких является функция app.get(). Она обрабатывает GET-запросы протокола HTTP и позволяет связать маршруты с определенными обработчиками. Для этого первым параметром передается маршрут, а вторым - обработчик, который будет вызываться, если запрос к серверу соответствует данному маршруту. Маршрут "/" представляет корневой маршрут.
middleware
Запросы:
Когда Express получает запрос, этот запрос передается в конвейер обработки. Конвейер состоит из набора компонентов или middleware, которые получают данные запроса и решают, как его обрабатывать. При необходимости мы можем встроить в конвейер обработки запроса на любом этапе любую функцию middleware. Для этого применяется метод app.use(). Функция, которая передается в app.use(), принимает три параметра:
    request: данные запроса
    response: объект для управления ответом
    next: следующая в конвейере обработки функция
Каждая из функций middleware просто выводит на консоль сообщение и в конце вызывает следующую функцию с помощью вызова next().Однако необязательно вызывать все последующие middleware, мы можем на каком-то этапе остановить обработку. Функции middleware также могут сопоставляться с определенными маршрутами. app.use("/about", function(request, response, next){}); В данном случае вторая функция middleware явно сопоставляется с маршрутом "/about", поэтому она будет обрабатывать только запрос "http://localhost:3000/about".
Middleware помогают выполнять некоторые задачи, которые должны быть сделаны до отправки ответа. Стандартная задача - логгирование запросов.
Ответы:
Для отправки ответа в express у объекта response можно использовать ряд функций. Самый распространенный способ отправки ответа представляет функция send()( response.send("<h2>Hello</h2>");), файлы отправлять с помощью функции sendFile()(response.sendFile(__dirname + "/index.html");). Функция sendStatus() отправляет пользователю определенный статусный код с некоторым сообщением по умолчанию.( response.sendStatus(404)).  Но, возможно, мы захотим отправлять какие-то свои более информативные сообщения. В этом случае можно использовать комбинацию функции status(), которая также отправляет статусный код, и функции send()( response.status(404).send(`Ресурс не найден`);).
Статические файлы
Статические файлы: файлы расположенные на стороне сервера и предназначенные для считывания их без изменения с помощью HTTP GET-запроса по имени ресурса, включающего имя файла. Пример: <link>, <script>, <img>, <audio>, <video>.
Для работы со статическими файлами в Express определен специальный компонент express.static(), который указывает на каталог с файлами.(у нас есть каталог public, в котором about.html Чтобы встроить компонент express.static в процесс обработки запроса, вызывается функция app.use(). Эта функция позволяет добавлять различные компоненты, которые еще называются middleware, в конвейер обработки запроса: app.use(express.static(__dirname + "/public"));  В саму же функцию express.static() передается путь к папке со статическими файлами. Специальное выражение __dirname позволяет получить полный путь к папке. апустим приложение на выполнение и обратимся в браузере по пути "http://localhost:3000/about.html")
Следует отметить, что для обращения к файлу мы указываем только имя файла без названия каталога public. Также не следует путать подобное обращение к файлам с действием функции sendFile: в данном случае мы напрямую обращаемся к статическим файлам, а функция sendFile фактически берет содержимое из файла и отсылает его пользователю.
Маршрутизация
При обработке запросов Express опирается на систему маршрутизации. В приложении определяются маршруты, а также обработчики этих маршрутов. Если запрос соответствует определенному маршруту, то вызывается для обработки запроса соответствующий обработчик.
Для обработки данных по определенному маршруту можно использовать ряд функций, в частности:
    use get post put delete
В качестве первого параметра эти функции могут принимать шаблон адреса, запрос по которому будет обрабатываться. Второй параметр функций представляет функцию, которая будет обрабатывать запрос по совпавшему с шаблоном адресу. Когда приходит запрос Express сопоставляет запрошенный адрес с каждым из маршрутов. Затем выбирается первый совпавший маршрут. При совпадении маршрута вызывается его функция обработчика.
Символы подстановок
Используемые шаблоны адресов могут содержать регулярные выражения или специальные символы подстановок. В частности, мы можем использовать такие символы, как ?, +, * и ().
К примеру, символ ? указывает, что предыдущий символ может встречаться 1 раз или отсутствовать. И мы можем определить следующую функцию:	
Символ + указывает, что предыдущий символ может встречаться 1 и более раз:	
Символ звездочка * указывает, что на месте данного символа может находиться любое количество символов:
Скобки () позволяют оформить группу символов, которые могут встречаться в запросе.
redirect
Для переадресации применяется метод redirect(): edirect([status,] path). В качестве параметра path передается путь, на который будет перенаправляться пользователь. Дополнительный параметр status задает статусный код переадресации. Если этот параметр не задан, тогда по умолчанию отправляется статусный код 302, который предполагает временную переадресацию. С помощью данного метода можно выполнять переадресацию как по относительным путям, так и по абсолютным, в том числе на другие домены.
Переадресация по абсолютному пути:
app.use("/index",function (request, response) {
  response.redirect("https://metanit.com")
});
Переадресация по оносительным путям также не очень сложна, но здесь важно учитывать, как именно определяется адрес для редиректа. Рассмотрим редирект относительно текущего пути, с которого производится редирект.
app.use("/home",function (request, response) {
  response.redirect("about")
});
app.use("/about", function (request, response) {
  response.send("<h1>About</h1>");
});
В данном случае будет идти перенаправление с ресурса "/home" на ресурс "/about", то есть, условно говоря, с http://localhost:3000/home на http://localhost:3000/about.
Если нам необходимо выполнить переадресацию не относительно текущего ресурса, а относительно корневого каталога приложения, то в начале адреса ставится слеш.
Параметры строки запроса
Одним из способов передачи данных в приложение представляет использование параметров строки запроса. Строка запроса (query) - фактически это часть запрошенного адреса, которая идет после знака вопроса. Например, в запросе http://localhost:3000/about?id=3&name=Tome часть id=3&name=Tome представляет строку запроса.
Строку запроса образуют параметры. После названия каждого параметра после знака равно (=) идет его значение. Друг от друга параметры отделяются знаком амперсанда. Например, в адресе выше использовалось два параметра: параметр "id" имеет значение "3" и параметр "name" имеет значение "Tom".
В express мы можем получить параметра строки запроса через свойство query объекта request, который передается в функцию обработки запроса. Например:
app.use("/about", function(request, response){ 
    let id = request.query.id;
    let userName = request.query.name;
    response.send("<h1>Информация</h1><p>id=" + id +"</p><p>name=" + userName + "</p>");});
С помощью выражения request.query мы можем получить все параметры строки запрос в виде объекта javascript, а с помощью выражения request.query.название_параметра мы можем обратиться к каждому отдельному параметру.
Параметры маршрута
Параметры маршрута представляют именованные сегменты URL-адреса. Не стоит их путать с параметрами строки запроса. Здесь параметры строки запроса - это то, что идет после вопросительного знака - id=3&name=Tome. Остальная часть, которая идет до вопросительного знака может содержать параметры маршрута.В определении маршрута параметры предваряются знаком двоеточия:
app.get("/products/:productId", function (request, response) {
  response.send("productId: " + request.params["productId"])
});
В данном случае параметр называется "productId". Через коллекцию request.params можно получить все параметры и, в частности, значение параметра productId.Если нам потребуется передать для этого параметра значение, то оно указывается в качестве последнего сегмента в строке запроса.
Router
Router позволяет определить дочерние подмаршруты со своими обработчиками относительно некоторого главного маршрута. 
// определяем Router
const productRouter = express.Router();
// определяем маршруты и их обработчики внутри роутера
productRouter.use("/create", function(request, response){
  response.send("Добавление товара");
});
productRouter.use("/", function(request, response){
  response.send("Список товаров");
});
// сопотавляем роутер с конечной точкой "/products"
app.use("/products", productRouter);
Шаблонизация
Шаблонизация: механизм генерации текстового на основе готового шаблона. 
Шаблон: (template) статический текст с вкраплениями  специальных символов (комбинацией символов), предназначенных для динамической генерации новых фрагментов текста. 
Шаблонизатор: (template engine) программа, выполняющая шаблонизацию. Языково-независимые шаблонизаторы (Mustashe).  
HBS: Handlebars – шаблонизатор, расширение Mustashe.
Чтобы установить Handlebars в качестве движка представлений в Express, вызывается функция: app.set("view engine", "hbs");
app.use("/contact", function(request, response){
    response.render("contact.hbs");
});
Для маршрута "/contact" используется функция обработчика, которая производит рендеринг представления "contact.hbs" с помощью функции response.render(). Эта функция на основе представления создает страницу html, которая отправляется клиенту.
1.	Поясните понятие Шаблонизация.
механизм генерации текстового на основе готового шаблона. 
2.	Поясните понятие Шаблон (template).
статический текст с вкраплениями  специальных символов (комбинацией символов), предназначенных для динамической генерации новых фрагментов текста.
3.	Поясните понятие Контекст шаблона (template context).
Данные передаваемые в шаблон
4.	Поясните понятие Макет (layout).
общий макет всех веб-страниц сайта
5.	Поясните понятие Частичное представление (partial-view).
Элементы представлений для вставки в шаблон
6.	Поясните понятие Хелпер (helper).
функции, которые возвращают некоторую строку
7.	Перечислите встроенные хелперы Handelbars.
If, each, with
8.	Поясните понятие Статический файл. 
это те которые отдаются в неизменном виде, которые серверу не нужно обрабатывать
9.	Поясните назначение  http-заголовков: 
Cache-control используется для задания инструкций кэширования как для запросов, так и для ответов.
ETag (или entity tag) — один из механизмов кэширования в HTTP. По сути это идентификатор, который присваивается файлу сервером для последующей проверки
Last-Modified в ответе HTTP содержит дату и время, в которую, по мнению удаленного сервера, запрашиваемый ресурс был изменен.
If-Modified-Since делает запрос условным: сервер отправит обратно запрошенный ресурс с статусом 200, только если он был изменен после указанной даты. Если запрос не был изменен после указанной даты, ответ будет 304 без какого-либо тела; заголовок Last-Modified при этом будет содержать дату последней модификации.
If-None-Match Для методов GET и HEAD сервер отправляет запрошенный ресурс только в том случае, если он соответствует одному из перечисленных ETags. Для PUT и других небезопасных методов он будет загружать только ресурс в этом случае.
10.	Поясните свойство  __dirname объекта global.
Возвращает расположение файла, а не расположение открытое в CMD
11.	Поясните назначение и принцип работы метода response.download().
Отправляет клиенту файл для скачивания
12.	Поясните назначение и принцип работы метода response.attachment().
Передает вложенный файл
13.	Поясните назначение  http-заголовков: Content-Disposition: attachment 
 индикатором того, что ожидаемый контент ответа будет отображаться в браузере, как вэб-страница или часть вэб-страницы, или же как вложение, которое затем может быть скачано и сохранено локально.

Модель представления
Одним из преимуществ шаблонов является то, что мы можем передавать в представления на место шаблонов модели представления - специальные объекты, данные которые использует движок представлений для рендеринга.
app.use("/contact", function(request, response){
    response.render("contact.hbs", {
        title: "Мои контакты",
        email: "gavgav@mycorp.com",
        phone: "+1234567890"
    });
});
 .hbs
 <!DOCTYPE html>
<html>
<head>
    <title>{{title}}</title>
    <meta charset="utf-8" />
</head>
<body>
    <h1>{{title}}</h1>
    <p>Электронный адрес: {{email}}</p>
    <p>Телефон: {{phone}}</p>
</body>
<html>
Вместо конкретных данных в коде представления используются те данные, которые определены в модели. Чтобы обратиться к свойствам модели в двойных фигурных скобках указывается нужное свойство: {{title}}. При рендеринге представления вместо подобных выражений будут вставляться значения соответствующих свойств модели.
Частичные представления в .hbs
Нередко вeб-страницы в приложении используют какие-то общие элементы. Это может быть меню, шапка сайта, футер, другие элементы. Однако здесь встает проблема: если потребуется поменять этот общий элемент, то придется вносить изменения на все веб-страницы, которые используют этот элемент. И было бы гораздо проще определить этот элемент в одном месте, а затем подключать на все страницы. Решить эту проблему помогают частичные представления (partial views), которые представляют разделяемые общие элементы, которые можно добавлять на обычные представления. Для этого создадим для частичных представлений в проекте подкаталог views/partials.
Для вставки частичного представления применяется выражение {{> name}}, в котором прописывается имя файла частичного представления без расширения.
Хелперы в .hbs
Хелперы фактически представляют функции, которые возвращают некоторую строку. После получения эту строку можно добавить в любое место представления. Хелперы позволяют оптимизировать создание кода представлений. В частности, мы можем один раз определить функцию хелпера, а затем многократно применять ее в самых различных местах для генерации кода.
Хелпер определяется с помощью функции hbs.registerHelper(). Первый параметр функции - название хелпера, а второй - функция, которая возвращает строку.
При этом, определив хелпер один раз, мы можем использовать многократно в различных представлениях, передавая ему различные значения.
Cookie
Cookie: фрагмент данных, оправленный web-сервером и хранимый web-клиентом. Используется для аутентификации,  хранения пользовательских предпочтений, статистики, информации о сеансе  (обычно Session ID). Обычно имеет имя, содержащее URL, может иметь срок действия.  Для создания и пересылки Cookie применяются заголовки.(RFC 6265: стандарт описывающий механизм Cookie.)  
Cookie:
	опция domain – привязка cookie к поддомену.
	опция path – путь, на который распространяется действие cookie.	
	опция maxAge – время жизни cookie в миллисекундах.
	опция Expires – дата истечения жизни cookie.  	опция secure – может применяться только с HTTPS.
	опция httpOnly = true – может изменяться сервером.
Session
Session: серверный объект, хранящий информацию о соединении с клиентом, создается при первом обращении  время жизни: timeout (системный параметр, обычно равен 10 – 30 минутам) – максимальное время между запросами клиента. Если  timeout превышен, то Session разрушается и при следующем запросе создается новый экземпляр. Каждая сессия имеет собственный идентификатор (Session ID, 16 или более байт). Каждый Request принадлежит, какой-то сессии (имеет ссылку на объект Session или содержит Session ID). Обычно объект Session предоставляет  приложению возможность хранить данные в формате ключ/значение.
Authentication 
Идентификация  – заявление пользователя о себе.
Аутентификация – процедура проверки подлинности идентификации пользователя.   
Авторизация  - процедура проверки прав аутентифицированного пользователя. 
Идентификация — процесс определения, что за человек перед нами. 
Аутентификация — процесс подтверждения, что этот человек именно тот, за кого себя выдает
Авторизация — процесс принятия решения о том, что именно этой аутентифицированной персоне разрешается делать.
Basic — наиболее простая схема, при которой username и password пользователя передаются в заголовке Authorization в незашифрованном виде (base64-encoded). Однако при использовании HTTPS (HTTP over SSL) протокола, является относительно безопасной.
Digest — challenge-response-схема, при которой сервер посылает уникальное значение nonce, а браузер передает MD5 хэш пароля пользователя, вычисленный с использованием указанного nonce. Более безопасная альтернативв Basic схемы при незащищенных соединениях, но подвержена man-in-the-middle attacks (с заменой схемы на basic). Кроме того, использование этой схемы не позволяет применить современные хэш-функции для хранения паролей пользователей на сервере.
Form - Работает это по следующему принципу: в веб-приложение включается HTML-форма, в которую пользователь должен ввести свои username/password и отправить их на сервер через HTTP POST для аутентификации. В случае успеха веб-приложение создает session token, который обычно помещается в browser cookies. При последующих веб-запросах session token автоматически передается на сервер и позволяет приложению получить информацию о текущем пользователе для авторизации запроса.
Сертификат X.509: стандартный формат хранения и  транспортировки  атрибутов безопасности; главное – открытый ключ; сертификаты выдают центры сертификации; сертификат содержит:  имя держателя, адрес, серийный номер сертификата,  даты проверки, открытый ключ держателя. 
TLS: 1) обеспечивает конфиденциальность; 2) обеспечивает целостность (обнаружение подмены); 3) аутентификация узлов (проверка подлинности источника сообщений); поверх потокового надежного соединения (для ненадежной передачи есть DTSL); Пересылает записи.
TLS:  Cipher Suites – шифронаборы; в шифронабор входит: криптосистема для аутентификации сервера и сеансового секрета; шифр для защиты передаваемых данных; хеш-функция для кода аутентификации HMAC.   
TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
ECDHE -  Диффи-Хеллман на эллиптических кривых для вычисления общего секрета;
ECDSA -     аутентификация данных на этапе установления соединения на основе цифровой подписи на эллиптических кривых;
AES_128 – шифрование полезной нагрузки с помощью алгоритма AES с 128-битным ключом в режиме GCM;
SHA256  - для хеширования применяется алгоритм SHA с 256-битным ключом. 
TLS: Схема работы  
Клиент выдает запрос серверу (Client Hello). 
Сервер подписывает свой сертификат и высылает клиенту (Server Hello). 
Клиент проверяет сертификат в центре сертификации, которому доверяет. 
Клиент  сравнивает данные сертификата с информацией центра сертификации.
Клиент сообщает серверу, какие ключи шифрования он поддерживает. 
Сервер выбирает подходящую длину ключа.
Клиент генерирует симметричный ключ, шифрует его открытым ключом. 
Сервер получает симметричный ключ и расшифровывает его.

NTLM (Windows authentication):  пароль не передается в чистом виде. Эта схема не является стандартом HTTP, но поддерживается большинством браузеров и веб-серверов. Преимущественно используется для аутентификации пользователей Windows  Active Directory в веб-приложениях.
Negotiate (Windows authentication): клиенту выбрать можно выбрать  между NTLM и  Kerberos -аутентификацией. Kerberos  –  протокол, основанный на принципе   Single Sign-On,  клиент  и сервер  должны находятся в зоне intranet  и являться частью домена   Windows.
Token-аутентификация
Token: битовая последовательность, построенная по определенному принципу. 
Token-аутентификация:  аутентификация, использующая token для идентификации пользователя или авторизации операции пользователя. 
Token-аутентификация: применяется, как правило,  для реализации Single Sign-On в распределенных системах.
Identity-provider   - сервер, генерирующий  token.
Service-provider – сервер, предоставляющий сервис клиенту. 
Token-аутентификация: активный клиент – программный код, который может выполнять любые запросы и обрабатывать любые ответы. Обычно – это пользовательская программная реализация http-клиента. Пассивный клиент – браузер.
Service-provider и Identity-provider должны иметь общий секретный ключ для шифрования/проверки token’а.
Token обычно строится на базе Issuer(эмитент),Audience (аудитория),Expires On (время жизни), Claim (сведение о пользователе) & Statements (дополнительные утверждения о пользователе), HMAC (хеш). 
Process
//Метод child_process.spawn запускает новый процесс с помощью заданной командой
//Метод spawn() возвращает потоки (stdout & stderr), он должен использоваться, когда процесс возвращает большой объем данных.
// spawn() начинает принимать ответ, сразу после начала выполнения процесса.

//Pipe - это канал, который связывает поток для чтения и поток для записи и позволяет сразу считать из потока чтения в поток записи.

//Метод child_process.exec запускает команду в оболочке и буферизирует вывод.
//command (String) — команда для запуска с аргументами, разделенными пробелом
//callback — функция принимает три аргумента error , stdout и stderr, которые вызываются с выходными данными при завершении процесса.
// Метод exec() возвращает буфер с максимальным размером и ожидает завершения процесса, после чего пытается сразу вернуть все буферизованные данные.
Метод child_process.fork является особым случаем spawn() для создания процессов Node.
//modulePath (String) — Модуль для запуска в дочернем элементе.
//args (Array) — Список аргументов строки
В дополнение к тому, что он содержит все методы, что и стандартный экземпляр дочернего процесса, метод fork возвращает объект со встроенным каналом связи.
Метод child_process.fork() является частным случаем child_process.spawn(), который используется определенно для создания новых процессов Node.js. Подобно child_process.spawn(),
 в итоге возвращается объект ChildProcess. Возвращаемый ChildProcess имеет дополнительные каналы связи, которые позволяют сообщениям передаваться по обоим направлениям (вперед-назад) между родительским и дочерним процессом.
Важно иметь в виду, что созданные дочерние процессы в Node.js являются независимыми от родительских, за исключением канала связи IPC, который устанавливается между ними.
Каждый процесс имеет собственную память, с собственными экземплярами V8. Из-за требований к дополнительному выделению ресурсов, не рекомендуется создание большого количества дочерних процессов.
По умолчанию, child_process.fork() создает новые экземпляры Node.js, используя process.execPath из родительского процесса. Свойство execPath в объекте позволяет использовать альтернативный путь выполнения.
Процессы Node.js, зпапускаемые с помощью кастомного execPath сообщаются с родительским процессом через файловый дескриптор (fd), который определяется переменной окружения NODE_CHANELL_FD в дочернем процессе. Входом и выходом в этом дескрипторе являются объекты JSON, разделенные строкой.
//Рассмотрим пример работы с потоками воркеров. У нас будет главный файл, index.js, в котором мы создадим поток воркера и передадим ему какие-то данные для обработки.
Соответствующий API основан на событиях, но я собираюсь использовать здесь промис, который разрешается при поступлении первого сообщения от воркера при создании воркера нужно передать конструктору Worker путь к файлу с кодом воркера и данные. Помните о том, что эти данные клонируются, а не хранятся в разделяемой памяти. После запуска воркера мы ожидаем сообщения от него, прослушивая событие message.
Выше мы, создавая объект типа Worker, передавали конструктору имя файла с кодом воркера — service.js.



Crypto
1.	Что такое хеш-функция?
Функция однозначно преобразующая входные данные в битовую последовательность с помощью алгоритма (функция сжатия)
2.	Что такое хеширование?
Действие производимое хеш-функцией
3.	Перечислите алгоритмы хеширования.
Семейства MD и SHA
4.	Поясните понятие «сеансовый ключ»
общий секрет — информация, которая вырабатывается на основе секретного ключа одной стороны и открытого ключа другой стороны
5.	Поясните понятия «публичный» и «секретный» ключи?
Секретный - ключ, известный только своему владельцу
Публичный - ключ, который может быть опубликован и используется для проверки подлинности подписанного документа
6.	Поясните понятие «дайджест».
Хеш-сумма - результат обработки неких данных хеш-функцией
7.	Для чего используется дайджест.
Значение хеш-суммы может использоваться для проверки целостности данных, их идентификации и поиска (например в P2P-сетях), а также заменять собой данные, которые небезопасно хранить в явном виде (например, пароли, ответы на вопросы тестов и т. д.). Также алгоритмы хеширования используются для проверки целостности и подлинности файлов.
8.	Поясните принцип работы алгоритма Диффи-Хеллмана.
Позволяет двум сторонам получить общий секретный ключ, используя незащищенный от прослушивания, но защищённый от подмены канал связи.

WebDav
WebDav: Web Distributed Authoring and Versioning – расширение протокола HTTP/HTTPS, поддерживающее совместную работу по управление файлами на удаленных web-северах; применяется для  создания сетевой файловой системы; в системах документооборота (document management system).
1.	Что такое WebDav?
Web Distributed Authoring and Versioning – расширение протокола HTTP/HTTPS, поддерживающее совместную работу по управление файлами на удаленных web-северах; применяется для  создания сетевой файловой системы; в системах документооборота (document management system).

2.	Назначение WebDav.
управление файлами на удаленных web-северах
3.	Перечислите основные функции WebDav.
o	Выполнение основных файловых операций над объектами на удаленном сервере;
o	Выполнение расширенных файловых операций (блокировки, поддержка версий);
o	Работа с любым типом объектов (не только файлы);
o	Поддержка метаданных (свойств) объектов;
·	Поддержка одновременной работы над объектами.
4.	Назовите несколько методов WebDav, расширяющих методы протокола HTTP.
·	PROPFIND — получение свойств объекта на сервере в формате XML. Также можно получать структуру репозитория (дерево каталогов);
·	PROPPATCH — изменение свойств за одну транзакцию;
·	MKCOL — создать коллекцию объектов (каталог в случае доступа к файлам);
·	COPY — копирование из одного URI в другой;
·	MOVE — перемещение из одного URI в другой;
·	LOCK — поставить блокировку на объекте. WebDAV поддерживает эксклюзивные и общие (shared) блокировки;
·	UNLOCK — снять блокировку с ресурса.

JSON-RPC
JSON-RPC: протокол удаленного вызова процедур, использующий формат JSON для передачи сообщений
JSON-RPC: объект запроса
 
JSON-RPC: объект ответа
 
JSON-RPC: объект ответа (ошибка)
 
1.	Что такое JSON RPC?
протокол удалённого вызова процедур, использующий JSON для кодирования сообщений
2.	Опишите формат RPC-запроса.
{
    "jsonrpc": "2.0",       // Признак спецификации (обязательный)
    "method": "subtract",   // Название метода, который должен быть выполнен на сервере (обязательный)
    "params": [42, 23],     // Параметры метода (не обязательное поле), массив, объект или простые типы
    "id": 1                 // Идентификатор запроса. Может отсутствовать, но в это случае сервер выполнит метод, но не вернет ответ (согласно спецификации)
}
3.	Позиционные параметры запроса.
"params": [42, 23]

4.	Именованные параметры запроса.
"params": {"subtrahend": 23, "minuend": 42}

5.	Опишите формат RPC-ответа.
{
    "jsonrpc": "2.0",       // Признак спецификации (обязательный)
    "result": 19,           // Результат - может быть любого типа
    "id": 1                 // Идентификатор ответа - всегда равен идентификатору запроса.
}
или ошибку
{
    "jsonrpc": "2.0",       // Признак спецификации (обязательный)
    "error": {              // Объект ошибки (обязательный)
        "code": -32601,                 // Код ошибки (обязательный, см. описание ошибок протокола)
        "message": "Method not found"   // Сообщение об ошибке (обязательный, см. описание ошибок протокола)
        "data": "nothing"               // Дополнительные данные об ошибке любого типа (не обязательный)
    },
    "id": "1"               // Идентификатор ответа - всегда равен идентификатору запроса.
}
6.	Что такое RPC-уведомление?
Информация для сервера, не требует ответа. Должен отсутствовать id
7.	Что такое пакет RPC-запросов? 
Тело запроса
WASM
WebAssembly – бинарный формат исполняемого  файла, который может исполняться в JavaScript Engine (виртуальная стековая машина). 
WASM: код быстрее, чем JS; поддерживается большинством браузеров; выполняется в sandbox; есть отладчики; открытый стандарт.   
1.	Что такое WASM?
это бинарный формат инструкций для стековой виртуальной машины
2.	Что такое emcc?
инструменты, необходимые для сборки вашего кода, и может выступать в качестве замены для стандартного компилятора, такого как gcc или clang

Swagger
Swagger: спецификация для описания  WEB API, ориентирована на REST, машинно-независимая и независимая от языков программирования, официальное название Open API.
Swagger: формат описания JSON или YAML, внутреннее представление JSON-объект. 
Swagger: альтернатива WSDL, но для описания интерфейса сервисов REST full API.
Swagger: предназначен для документирования сервисов и автоматизированной генерации кода REST full API. 
1.	Что  такое OpenAPI Specification (Swagger)?
API для создания, документирования и использования веб-сервисы RESTful

        BOT
лонг пул запрос, и как работает (pooling^true это есть лонг пул)
	(сервер должен обеспечить лонг пул, мы делаем запрос а серверу нечем нам ответить, и сервер как
	 бы не отвечает заданное наперед время, если есть сразу ответ то сразу отвечает, если нечем
	 ответить то ждет событие на корое он может ответить, и время которое он ждет- 
	системный параметр, если нет события то отправляет на клиент что ничего гнет пока, 
	и он опять отправляет запрос, и такой цикл позволяет получапть инфу что происходит на сервере
		в логпул важен таймаут который выдерживает сервер до событии, задача лонг пула узнать
		 что происходит на сервере и он постоянно делает запросы на сервер и ждет событие, но
		 может оказаться что на сервере нет этого события, поэтому сервер получив  запрос ничего
		 не отправляет а тоже ждет этого события, после того как клиент получил ответ он делает
		 опять запрос
1.	Поясните принцип работы  LongPoll-сервера?
1.	Отправляется запрос на сервер
2.	Соединение не закрывается сервером
o	пока не появится событие
3.	Событие отправляется в ответ на запрос
4.	Клиент тут же отправляет новый ожидающий запрос
